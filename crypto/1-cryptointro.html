<link rel="stylesheet" href="../homepage/envoy.min.css">

<style>
	#code {
    width:900px;
    margin:0 auto;   
    /*temporary text styles below*/
    text-align:left;
    font-weight:bold;
    background: rgb(170,204,153);
  }
  main {
    margin-bottom: 200%;
  }
  .floating-menu {
    font-family: sans-serif;
    background: transparent;
    padding: 5px;;
    width: 80px;
    z-index: 100;
    position: fixed;
    top: 0px;
    right: 0px;
  }
  .floating-menu a, 
  .floating-menu h3 {
    font-size: 0.9em;
    display: block;
    margin: 0 0.5em;
    color: white;
  }
  .floating-menu a:hover{
    background: yellowgreen;
  }
</style>

  <nav class="floating-menu">
    <a href="../homepage2.html">Home</a>
    <a href="../bitcoin/0-bitcoinhomepage.html">Bitcoin</a>
    <a href="0-cryptohomepage.html">Crypto</a>
    <a href="../linearalgebra/0-linearalgebrahomepage.html">Algebra</a>
  </nav>

<div class="col col-10 px2 js-linksHeight">
<h3 class="red h2 mt0 mb4 px3">
Cryptography 101</h3>
<div class="mbn2 relative">
<div class="js-active-tab z2" style="pointer-events: none;"></div>
<ul class="list-style-none z3 js-galleryLinks">
<li class="p3 js-animateTab js-activeLink" data-tab="0">
<h3 class="mt0 mb1 slate blue h2">
Exclusive OR
</h3>
<p class="m0">
<img src="fig1.1-crypto-xor.webp" height="40%" width="40%"></img><p/>
XOR: Boolean binary operator that is true when either the first input or the second input, but not both, are true.
Generally represented by a cross in a circle: <img src="xor.png"></img><p/>
</p>
<p/>
<p class="m0">
<img src="fig1.2-invertingbit.png" height="40%" width="40%"></img><p/>
XOR: programmable inverter; one input bit decides whether to invert the other input bit.<p/>
Pi = plain text bit<br>
ki = key bit<br>
Ci = cipher text bit (result of XOR operation)
</p>
<p/>

</li>

<li class="p3 js-animateTab " data-tab="1">

<h3 class="mt0 mb1 slate h5">
XOR Properties
</h3>
<p class="m0">
1. a<img src="xor.png"/>(b<img src="xor.png">c) = (a<img src="xor.png">b)<img src="xor.png">c<br>
2. a<img src="xor.png">b = b<img src="xor.png">a<br>
3. Any bit XOR itself is zero: a<img src="xor.png">a = 0<br>
4. Any bit XOR zero is that bit again: a<img src="xor.png">0 = a<br>
This also implies:
a<img src="xor.png">b<img src="xor.png">a<br>
= a<img src="xor.png">a<img src="xor.png">b<br>
= 0<img src="xor.png">b<br>
= b<br>
</p>
<p/>

</li>

<li class="p3 js-animateTab " data-tab="2">
<h3 class="mt0 mb1 slate h5">Bitwise XOR</h3>

<p class="m0">
A "bitwise XOR" operator performs XOR on respective bits of two values.
Python, for example, provides the ^ operator that performs bitwise XOR on integers.  e.g.<br>
73<img src="xor.png">87 = 0b1001001 <img src="xor.png"> 0b1010111<br>
= 1  0  0  1  0  0  1<br>
&nbsp;<img src="xor.png" width=11 height=11/> <img src="xor.png" width=11 height=11/> <img src="xor.png" width=11 height=11> <img src="xor.png" width=11 height=11> <img src="xor.png" width=11 height=11> <img src="xor.png" width=11 height=11> <img src="xor.png" width=11 height=11><br>
&nbsp;&nbsp;1  0  1  0&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1<br>
= 0  0  1  1  1  1  0<br>
= 30<p/>
</p>
<p/>

</li>



<li class="p3 js-animateTab " data-tab="7">
<h3 class="mt0 mb1 slate blue h2">Symmetric-Key Encryption</h3>

<pre>
Symmetric Meaning using the same key.
</pre>
<p/>
<pre>
There are two types of ciphers:
* <font color=green>Block Cipher:</font> process plaintext of fixed length
C=E(K, M)
C and M are both binary with length n
K is binary with length r

n is called block length of the cipher

Typical block lengths n are 64 (DES) or 128 (AES)
Typical key lengths r are 56 (DES) or 128, 192, 256 (AES)

There are 2 ** n plaintext blocks and 2 ** n cipher text blocks of length n.
The Function E maps {0, 1}n bijectively to {0, 1}n
To choose a key k, means to select a permutation Ek of {0, 1}n

Max security = choose randomly for all n bits.  But 2 ** n key length is too long, too much for storage.  So get a shorter key.

* <font color=green>Stream Cipher:</font> process plaintext of streams
C = E(K, M) / M = D(K, C)
c1 = E(k1, m1), c2 = E(k2, m2), c3 ...
m1 = D(k1, c1), m2 = D(k2, c2), m3 ...
ci / mi / ki are binary bits or bytes
</pre>
<p/>

</li>



<li class="p3 js-animateTab " data-tab="3">
<h3 class="mt0 mb1 slate h5">One-Time Pads</h3>
<p class="m0">
A Pad is a sequence of key bits generated purely random, and never used again.
The attackers learn nothing about the plaintext when they see a ciphertext.
Let's say Eve sees a ciphertext bit Ci is 1.  She has no idea if the plaintext or key bit is 0 or 1.
</p>
<p/>


</li>




<li class="p3 js-animateTab " data-tab="4">
<h3 class="mt0 mb1 slate h5">Attacks on One-Time Pads</h3>

<p class="m0">
OTP only holds if: it contains <font color=green>truly random data</font>; it can only be used <font color=green>once</font>.
</p>
<p/>

<p class="m0">
Reusing OTP reveals the plaintext to a certain level.  Because:<br>
C1 = P1 <img src="xor.png" width=11 height=11/> key<br>
C2 = P2 <img src="xor.png" width=11 height=11/> key<br>
So, C1 <img src="xor.png" width=11 height=11/> C2 = P1 <img src="xor.png" width=11 height=11/> P2 <img src="xor.png" width=11 height=11/> key <img src="xor.png" width=11 height=11/> key<br>
= P1 <img src="xor.png" width=11 height=11/> P2 <img src="xor.png" width=11 height=11/> 0
= P1 <img src="xor.png" width=11 height=11/> P2
</p>
<p/>
<p class="m0">
Illustration of (f) = P1 <img src="xor.png" width=11 height=11/> P2:<br>
<img src=fig1.3-attackotp.png></img>
</p>
<p/>

<p class="m0">
S
</p>
<p/>

</li>





<li class="p3 js-animateTab " data-tab="5">
<h3 class="mt0 mb1 slate h5">Crib Dragging</h3>

<pre>
Let's take the following message and key:
message = "Hello World"
key = "supersecret" 

If we convert both the message and key to hex strings, we get the following:

message = "48656c6c6f20576f726c64"
key = "7375706572736563726574"

If we do a simple XOR of the two hex strings we get the following cipher-text:

cipher-text = "3b101c091d53320c000910"

what happens when you have two messages encrypted with the same key. Take the following two messages and key:

message1 = "Hello World"
message2 = "the program"
key = "supersecret"

If we convert each message and the key to hex strings, and then encrypt each message using a simple XOR with the key, <br>we'll get the following cipher-texts:

cipher-text1: "3b101c091d53320c000910"
cipher-text2: "071d154502010a04000419"


Let's say that all we have is the two cipher-texts and the knowledge that they were encrypted with a supposed OTP; however, <br>they were both encrypted with the same key. To attack this encryption and uncover the plain-text, follow the steps below.

Guess a word that might appear in one of the messages
Encode the word from step 1 to a hex string
XOR the two cipher-text messages
XOR the hex string from step 2 at each position of the XOR of the two cipher-texts (from step 3)
When the result from step 4 is readable text, we guess the English word and expand our crib search.
If the result is not readable text, we try an XOR of the crib word at the next position.

Step 1 seems difficult (guessing a word that might appear in one of the messages), but when you think about it, the word "the" <br>is the most commonly used English word. So, we'll start with assuming "the" is in one of the messages. After encoding "the"<br>as a hex string, we'll get "746865". That takes care of steps 1 and 2. If we XOR the two cipher-texts, we'll get the following result:

cipher-text1 XOR cipher-text2 = "3c0d094c1f523808000d09"

The next step is to XOR our crib word "746865" at each position of the XOR of the cipher-texts. What we'll do is slide "746865" <br>along each position of "3c0d094c1f523808000d09" and analyze the result. After the first XOR, we get the following result:

     3c0d094c1f523808000d09
XOR  746865
----------------------------------
     48656c

When we convert the hex string "48656c" to ASCII, we get the following text, "Hel". This takes us to step 5 from above. Because<br>this looks like readable text, we can assume that the word "the" is in the first position of one message. If we didn't get<br>readable text, we would slide "746865 (the)" one position to the right and try again (and keep repeating until the end of 3c0d094c1f523808000d09).

Note that we don't know which message contains the word "the". It could be in either message1 or message2. Next, we need to guess<br>what the word "Hel" is when fully expanded. It could be "Help", "Hello", etc. If we guess "Hello", we can convert "Hello"<br>to a hex string, we get "". We then XOR it with the XOR of the two cipher-texts (just like we did with "the"). Here's the result:

     3c0d094c1f523808000d09
XOR  48656c6c6f
----------------------------------
     7468652070

"7468652070"  when converted to ASCII, is "the p". We then repeat the process, guessing what "the p" might be when expanded and then<br> XOR that result with the XOR of the cipher-texts. Granted, guessing what "the p" might expand to is not super easy, but you get the idea.<br>If we were to guess "the program", convert it to a hex string, and XOR it with the XOR of the cipher-texts, we'll get "Hello World".
</pre>
<p/>
<p class="m0">
Python Code:
<pre id="code">
>>> message="Hello World"
>>> key    ="supersecret"
>>> b_message = message.encode('ascii')
>>> b_key     = key.encode('ascii')
>>> c = [m_byte^k_byte for (m_byte, k_byte) in zip(b_message, b_key)]
>>> c
[59, 16, 28, 9, 29, 83, 50, 12, 0, 9, 16]
>>> bytes(c)
b';\x10\x1c\t\x1dS2\x0c\x00\t\x10'
>>> message2 = "the program"
>>> b_message2 = message2.encode('ascii')
>>> c2 = [m2_byte^k_byte for (m2_byte, k_byte) in zip(b_message2, b_key)]
>>> c2
[7, 29, 21, 69, 2, 1, 10, 4, 0, 4, 25]
>>> the = "the"
>>> the_crab = the.encode("ascii")
>>> the_crab
b'the'
>>> the_crab[0]
116
>>> the_crab[1]
104
>>> bytes(c2)
b'\x07\x1d\x15E\x02\x01\n\x04\x00\x04\x19'
>>> c12 = [c1_bit^c2_bit for (c1_bit, c2_bit) in zip(c, c2)]
>>> c12
[60, 13, 9, 76, 31, 82, 56, 8, 0, 13, 9]
>>> first_guess = [crab_bit^c_bit for (crab_bit, c_bit) in zip(the_crab, c12[0:3])]
>>> first_guess
[72, 101, 108]
>>> first_guess_chr = [chr(guess) for guess in first_guess]
>>> first_guess_chr
['H', 'e', 'l']
</pre>
</p>
<p/>

<p class="m0">
S
</p>
<p/>

</li>





<li class="p3 js-animateTab " data-tab="6">
<h3 class="mt0 mb1 slate h5">Other problems of OTP</h3>

<pre>
* The key should be at least as large as the plaintext
* You need to transfer the keys securely to all recipients.
* Generating large sized keys purely random is time consuming.

We need keys with manageable sizes and transfer them over the Internet.
</pre>
<p/>

<p class="m0">
C
</p>
<p/>

</li>




<li class="p3 js-animateTab " data-tab="7">
<h3 class="mt0 mb1 slate blue h2">Block Ciphers</h3>

<pre>
<font color=green>block cipher</font> = algorithm that allows us to encrypt
blocks of fixed length.  It provides function E to turn plaintext block P
into ciphertext blocks C, using a secret key k:
                          C = E(k, P)

<font color=green>block size</font> = Length(C) = Length(P)
k is in [keys], which is called keyspace

Later, the ciphertext block can be decrypted using function D:
                          P = D(k, C)

<img src="fig1.4-blockcipher.png" width="60%" height="60%"></img>


<font color=green>block cipher</font> = <font color=red>symmetric-key encryption</font> OR <font color=red>secret-key encryption</font> scheme
Meaning: same key is used for both Encryption and Decryption.

<font color=green>block cipher</font> is also <font color=red>keyed permutation</font>.

{Permutations of P blocks}    <=== maps to === by key ===>    {Permutations of C blocks}
</pre>
<p/>
<pre>

</pre>
<p/>

</li>








<li class="p3 js-animateTab " data-tab="7">
<h3 class="mt0 mb1 slate h5">DES</h3>

<pre>
<font color=green>DES</font> = Data Encryption Standard

<font color=green>DES</font> = FIPS46, 1977

<font color=green>DES</font> = 56 bits key length, 64 bits plaintext length, 16 rounds (16 major steps)

In each round, a 48-bit round key ki is used.  The 16 round keys k1, k2, ... k16 are computed from the 56 bit key k.

Basic building block of DES: f = map {0, 1}48 * {0, 1}32 -> {0, 1}32

f(k', x) = P(S(E(x) xor k'))

Eight substitution boxes.

</pre>
<p/>
<p class="m0">
B
</p>
<p/>

</li>










<li class="p3 js-animateTab " data-tab="7">
<h3 class="mt0 mb1 slate h5">AES</h3>

<pre>
<font color=green>AES</font> = Advanced Encryption Standard

<font color=green>AES</font> = Rijndael, Belgian cryptographers Vincent Rijmen + Joan Daemen

<font color=green>Rijndael</font> = A family of block ciphers, with block sizes and key sizes that could be any multiple of
32 bits between 128 bits and 256 bits.

When Rijndael becomes AES (FIPS-197), block size = 128 bites, key size = 128 / 192 / 256 bits.
FIPS = Federal Information Processing Standards

A closer look at AES:
<a href="2-cryptoaes.html">AES</a>

</pre>
<p/>
<p class="m0">
B
</p>
<p/>

</li>


</ul>
</div>


